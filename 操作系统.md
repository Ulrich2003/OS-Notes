# 操作系统

### 进程

#### 进程的定义

**程序段、数据段，PCB**三部分组成了进程实体，所谓的创建进程，实质上是创建进程实体中的PCB

**注意⚠️：PCB是进程存在的唯一标识**

**定义：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位**

![image-20211102145920896](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211102145920896.png)

#### 进程的状态

![image-20211102151119457](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211102151119457.png)

#### 进程状态的转换

![image-20211102152220009](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211102152220009.png)

#### 进程控制

简单理解为：进程控制为要实现进程状态的转换

进程控制无非要做3类事情：

- 更新PCB中的信息
- 将PCB插入合适的队列
- 分配/回收资源♻️

##### 进程的创建

无 -> 创建态 -> 就绪态

![image-20211102160425793](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211102160425793.png)

##### 进程的撤销

就绪态/阻塞态/运行态 -> 终止态 -> 🈚️

![image-20211102161100365](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211102161100365.png)

##### 进程的阻塞和唤醒

![image-20211102162758636](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211102162758636.png)

##### 进程的切换

![image-20211102165313658](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211102165313658.png)

### 进程通讯

进程是分配系统资源的单位，因此各个进程拥有的内存地址空间相互独立

为了保证安全🔐，一个进程是不能直接访问另一个进程的地址空间

#### 共享存储

![image-20211102170236664](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211102170236664.png)

#### 管道通讯

![image-20211102170401809](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211102170401809.png)

1. 管道只能采用**半双工通讯**，某一段时间内只能实现单向的传输。如果要实现**双向同时通讯**，则需要设置两个管道
2. 各进程要互斥地访问管道
3. 数据以字符流的形式写入管道，当管道写满时，写进程write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程read()系统调用将被阻塞。
4. 如果没有写满，是不允许读的。如果没有读空，是不允许写的。

5. 数据一旦被读出，就从管道中抛弃，这就意味着**读进程最多只能有一个**，否则可能会有读错数据的情况（不然可能会出现读错数据的情况）

#### 消息传递

 进程间的数据交换以**格式化的消息**为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。

![image-20211103204859147](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211103204859147.png)

1. 直接通信方式

消息直接挂到接收进程的消息缓冲队列上

![image-20211103205103826](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211103205103826.png)

2. 间接通信方式

消息要先发送到中间实体（信箱📪）中，因此也称为“信箱通信方式”

![image-20211103205343521](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211103205343521.png)

### 线程概念和多线程模型

线程是一个基本的CPU执行单元，也是**程序执行流的最小单位**。

传统进程机制中，进程是资源分配、调度的基本单位，引入线程后，**进程是资源分配的基本单位，线程是调度的基本单位**

引入线程后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发的处理各种任务

引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机，内存地址空间等都是分配给进程的）

<img src="https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211103211632449.png" alt="image-20211103211632449" style="zoom:50%;" />

进程的属性：

![image-20211103212724976](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211103212724976.png)

#### 进程的实现方式

![image-20211103213955627](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211103213955627.png)

##### 用户级线程（从用户视角看到的进程）

用户级进程由应用程序通过线程库实现。所有**线程管理工作**都由**应用程序负责**

用于级线程中，线程切换可以在用户态下即可完成，无须操作系统干预

在用户看来，是由多个线程，但在操作系统内核看来，并意识不到线程的存在（用户级线程对用户不透明，对操作系统透明）

##### 内核级线程

内核级线程就是「从操作系统内核视角看到能看到的线程」

内核级线程的管理工作由操作系统内核完成。线程调度，切换等工作都由内核负责，因此**内核级线程的切换**必然需要在**核心态**下才能完成

#### 多线程模型

##### 多对一模型

每个用户级线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。

优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高

缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行

![image-20211103215836633](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211103215836633.png)

##### 一对一模型

一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。

优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强，多线程可在多核处理机上并行执行。

缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。

![image-20211103220830844](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211103220830844.png)

##### 多对多模型

克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。

![image-20211103220505416](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211103220505416.png)

### 处理机调度

#### 调度的三个层次

##### 高级调度（作业调度）

按一定的原则从**外存上**处于后备队列的作业中挑选一个（或多个）作业，给他们分配**内存**等必要资源，并建立相应的进程（建立PCB），以使他们获得竞争处理机的权利。

![image-20211104123616950](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211104123616950.png)

高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。 作业调入时会建立相应的PCB，作业调出时才会撤销PCB。高级调度主要是🈯️调入问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。

##### 中级调度（内存调度）

引入虚拟存储技术之后，可将暂时不能运行的进程调至外存等待⌛️。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。

这么做的目的是为了提高内存利用率和系统吞吐量。

暂时调到外存等待的进程状态为挂起状态，值得注意的是，PCB并不会一起调到外存，而是会常驻在内存中。PCB中会记录进程数据在外存中存放到位置📝，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程会被放到挂起队列中。

![image-20211104125125244](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211104125125244.png)

中级调度，就是要决定将哪个处于挂起状态的进程重新调入内存。一个进程可能会被多次调出，调入内存，因此中级调度发生的频率要比高级调度更高。

##### 低级调度（进程调度）

主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。

进程调度是操作系统中**最基本的一种调度**，在一般操作系统中都必须配置进程调度。进程调度频率很高，一般几十毫秒一次。

![image-20211104130759663](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211104130759663.png)

#### 进程的挂起态和七状态模型

暂时调到外存等待的进程状态称为挂起状态

挂起态又可以进一步细分为就绪挂起，阻塞挂起两种状态

![image-20211104125726372](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211104125726372.png)

![image-20211104130950595](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211104130950595.png)

