# 操作系统

### 进程

#### 进程的定义

**程序段、数据段，PCB**三部分组成了进程实体，所谓的创建进程，实质上是创建进程实体中的PCB

**注意⚠️：PCB是进程存在的唯一标识**

**定义：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位**

![image-20211102145920896](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211102145920896.png)

#### 进程的状态

![image-20211102151119457](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211102151119457.png)

#### 进程状态的转换

![image-20211102152220009](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211102152220009.png)

#### 进程控制

简单理解为：进程控制为要实现进程状态的转换

进程控制无非要做3类事情：

- 更新PCB中的信息
- 将PCB插入合适的队列
- 分配/回收资源♻️

##### 进程的创建

无 -> 创建态 -> 就绪态

![image-20211102160425793](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211102160425793.png)

##### 进程的撤销

就绪态/阻塞态/运行态 -> 终止态 -> 🈚️

![image-20211102161100365](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211102161100365.png)

##### 进程的阻塞和唤醒

![image-20211102162758636](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211102162758636.png)

##### 进程的切换

![image-20211102165313658](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211102165313658.png)

### 进程通讯

进程是分配系统资源的单位，因此各个进程拥有的内存地址空间相互独立

为了保证安全🔐，一个进程是不能直接访问另一个进程的地址空间

#### 共享存储

![image-20211102170236664](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211102170236664.png)

#### 管道通讯

![image-20211102170401809](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211102170401809.png)

1. 管道只能采用**半双工通讯**，某一段时间内只能实现单向的传输。如果要实现**双向同时通讯**，则需要设置两个管道
2. 各进程要互斥地访问管道
3. 数据以字符流的形式写入管道，当管道写满时，写进程write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程read()系统调用将被阻塞。
4. 如果没有写满，是不允许读的。如果没有读空，是不允许写的。

5. 数据一旦被读出，就从管道中抛弃，这就意味着**读进程最多只能有一个**，否则可能会有读错数据的情况（不然可能会出现读错数据的情况）

#### 消息传递

 进程间的数据交换以**格式化的消息**为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。

![image-20211103204859147](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211103204859147.png)

1. 直接通信方式

消息直接挂到接收进程的消息缓冲队列上

![image-20211103205103826](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211103205103826.png)

2. 间接通信方式

消息要先发送到中间实体（信箱📪）中，因此也称为“信箱通信方式”

![image-20211103205343521](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211103205343521.png)

### 线程概念和多线程模型

线程是一个基本的CPU执行单元，也是**程序执行流的最小单位**。

传统进程机制中，进程是资源分配、调度的基本单位，引入线程后，**进程是资源分配的基本单位，线程是调度的基本单位**

引入线程后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发的处理各种任务

引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机，内存地址空间等都是分配给进程的）

<img src="https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211103211632449.png" alt="image-20211103211632449" style="zoom:50%;" />

进程的属性：

![image-20211103212724976](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211103212724976.png)

#### 进程的实现方式

![image-20211103213955627](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211103213955627.png)

##### 用户级线程（从用户视角看到的进程）

用户级进程由应用程序通过线程库实现。所有**线程管理工作**都由**应用程序负责**

用于级线程中，线程切换可以在用户态下即可完成，无须操作系统干预

在用户看来，是由多个线程，但在操作系统内核看来，并意识不到线程的存在（用户级线程对用户不透明，对操作系统透明）

##### 内核级线程

内核级线程就是「从操作系统内核视角看到能看到的线程」

内核级线程的管理工作由操作系统内核完成。线程调度，切换等工作都由内核负责，因此**内核级线程的切换**必然需要在**核心态**下才能完成

#### 多线程模型

##### 多对一模型

每个用户级线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。

优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高

缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行

![image-20211103215836633](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211103215836633.png)

##### 一对一模型

一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。

优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强，多线程可在多核处理机上并行执行。

缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。

![image-20211103220830844](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211103220830844.png)

##### 多对多模型

克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。

![image-20211103220505416](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211103220505416.png)

### 处理机调度

#### 调度的三个层次

##### 高级调度（作业调度）

按一定的原则从**外存上**处于后备队列的作业中挑选一个（或多个）作业，给他们分配**内存**等必要资源，并建立相应的进程（建立PCB），以使他们获得竞争处理机的权利。

![image-20211104123616950](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211104123616950.png)

高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。 作业调入时会建立相应的PCB，作业调出时才会撤销PCB。高级调度主要是🈯️调入问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。

##### 中级调度（内存调度）

引入虚拟存储技术之后，可将暂时不能运行的进程调至外存等待⌛️。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。

这么做的目的是为了提高内存利用率和系统吞吐量。

暂时调到外存等待的进程状态为挂起状态，值得注意的是，PCB并不会一起调到外存，而是会常驻在内存中。PCB中会记录进程数据在外存中存放到位置📝，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程会被放到挂起队列中。

![image-20211104125125244](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211104125125244.png)

中级调度，就是要决定将哪个处于挂起状态的进程重新调入内存。一个进程可能会被多次调出，调入内存，因此中级调度发生的频率要比高级调度更高。

##### 低级调度（进程调度）

主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。

进程调度是操作系统中**最基本的一种调度**，在一般操作系统中都必须配置进程调度。进程调度频率很高，一般几十毫秒一次。

![image-20211104130759663](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211104130759663.png)

#### 进程的挂起态和七状态模型

暂时调到外存等待的进程状态称为挂起状态

挂起态又可以进一步细分为就绪挂起，阻塞挂起两种状态

![image-20211104125726372](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211104125726372.png)

![image-20211104130950595](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211104130950595.png)

### 进程调度的时机、切换的过程

进程调度（低级调度），就是按照某种算法重就绪队列中选择一个进程为其分配处理机

![image-20211104132435027](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211104132435027.png)

#### 进程调度的方式

##### 非剥夺方式

又称为非抢占方式，只允许进程主动放弃处理机，在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。

##### 剥夺调度方式

又称抢占方式。如果有一个更重要，更急迫的进程需要使用处理机，则立刻暂停正在执行的过程，将处理机分配给更重要紧迫的那个进程

#### “狭义的进程调度”与“进程切换”的区别

狭义的进程调度指的是从就绪 ☑️ 队列中选一个要运行的进程（这个进程可以是刚刚被暂停执行的进程 ⏸️，也可能是另一个进程，后一种情况就需要进程切换）

进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。

广义的进程调度包含了选择一个进程和进程切换两个步骤。

进程切换的过程主要完成了✅：

1. 对原来运行进程各种数据的保存
2. 对新的进程的各种数据的恢复

注意⚠️：进程切换是有代价的，如果过于频繁的进行进程调度、切换，会使整个系统的效率降低。使系统大部分时间都花在了进程切换上。

### 调度算法的评价指标

![image-20211109160530450](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211109160530450.png)

##### 等待时间

![image-20211109150714283](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211109150714283.png)

### FCFS、SJF、HRRN 调度算法

![image-20211109161347453](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211109161347453.png)

#### FCFS（First Come First Serve）

算法思想：公平角度考虑

算法规则：先来先服务

用于作业调度时：考虑的是哪个作业先到达后备队列

用于进程调度时：考虑的是哪个进程先到达就绪队列

是否🉑️抢占 ？ F

优点：公平，算法实现简单

缺点：排在长作业后面的短作业需要等待很长的时间⌛️，带权周转时间很大，对短作业来说作业体验非常不好👎。

是否会导致饥饿 ？ F

#### SJF（Shortest Job First）

算法思想：追求最少的平均等待时间，最少的平均周转时间、最少的平均带权周转时间

算法规则：短作业优先

🉑️用于作业调度，也可进程调度。用于进程调度时称为“短进程优先”（Shortest Process First）算法

是否🉑️抢占 ？ SJF是非抢占式算法，但是也有抢占式版本 -- 最短剩余时间优先算法（SRTN，Shortest Remaining Time Next）

优缺点：

优点：“最短的” （不严谨） 平均等待时间⌛️，平均周转时间

缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定真正做到短作业优先

长作业/进程如果因为有源源不断的短作业/进程到来，可能会产生“饿死”现象

#### 做题细节

1. 如果题目没有特别说明，所提到的“短作业/进程优先算法”默认是非抢占式的

#### HRRN（Highest Response Ratio Next）

算法思想：综合考虑作业/进程的等待时间和要求服务的时间

算法规则：每次调度时先计算🧮各个进程的响应比，选择响应比高的作业/进程为其服务。

![image-20211116144811887](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211116144811887.png)

🉑️用于作业调度，也可用于进程调度

是否可抢占？**非抢占式**的算法，因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比

优点：综合考虑了等待时间和运行时间⌚️

等待时间相同时：要求服务时间短的优先（SJF）

要求服务时间相同时，等待时间长的优先（FCFS）

对于长作业来说，等待时间越长，响应比会越来越大，这样有效避免长作业饥饿的问题

是否会导致饥饿：❌

#### 时间片轮转（RR, Round-Robin）

 算法思想：公平，轮流为各进程服务；让每个进程在一定时间间隔内都可以得到相应

算法规则：按照各进程到达顺序，轮流让各个进程执行一个时间片。如果在一个时间片内没有执行完，则剥夺处理机，将进程重新放入就绪队列队尾重新排队

用于进程调度（只有作业放入内存建立相应的进程后，才能被分配处理机时间片）

可否抢占：☑️

优点：公平，适合分时操作系统

缺点：高频率进程切换下有一定开销，不区分任务的紧急程度‼️

是否会导致饥饿：❌

#### 优先级调度算法

算法思想：越来越多的应用场景需要根据任务的紧急程度来处理顺序

算法规则：每个作业/进程都有自己的优先级，调度时选择优先级最高的作业/进程

既可以用于作业调度，也可以用于进程调度，甚至，还会用于I/O调度

是否可以抢占？ 都有

优点：适用于实时操作系统

缺点：若源源不断🈶️高优先级进程到来，则可能导致饥饿

是否会导致饥饿：☑️

#### 多级反馈队列调度算法

算法思想：对其他调度算法的折中权衡

算法规则：

1.设置多级就绪队列，各级队列优先级从高到低，时间片从小到大

2.新进程到达时先进入第1⃣️级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果已经是在最下级，则重新放回改队列队尾

3.只有第k级队列为空时，才会为k+1级队头的进程分配时间片用于进程调度

可否抢占：☑️

![image-20211118194333583](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211118194333583.png)

优缺点： 对各类进程相对公平，每个新到达的进程都可以很快就得到响应

是否会导致饥饿：☑️

 ### 进程同步，进程互斥

#### 互斥共享方式

系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源

我们把一个时间段内只允许一个进程使用的资源称为临界资源，如摄像头，打印机，此外还有许多变量，数据，内存缓冲区等都属于临界资源

对临界资源的互斥访问，可以在逻辑上分为四部分

![image-20211119084604352](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211119084604352.png)

##### 进程互斥需要遵循的原则

1. 空闲让进。临界区为空闲时，允许请求进入临界区进程立即进入临界区
2. 忙则等待。
3. 有限等待。对请求访问的进程，必须保证能在有限时间内进入临界区（不饥饿）
4. 让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待

##### 进程互斥的软件实现方法

❌单标志法：

![image-20211119085901657](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211119085901657.png)

❌双标志先检查法：

![image-20211119090649817](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211119090649817.png)

❌双标志后检查法：

![image-20211119091235933](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211119091235933.png)

❎ Peterson算法：

![image-20211119092138583](https://vichien-public.oss-cn-guangzhou.aliyuncs.com/typora/image-20211119092138583.png)

##### 进程互斥的硬件实现方法

**中断屏蔽方法**

使用开/关中断指令来实现

优点：简单高效

缺点：只适用于单处理机；只适用于操作系统内核进程

**TSL （TestAndSet）指令**

执行过程中不允许被中断，只能一气呵成

优点：实现简单；适用于多处理机环境

缺点：不满足让权等待原则，可能会出现忙等

**Swap指令**

执行过程中不允许被中断，只能一气呵成，逻辑上和TSL并没有太大区别

优点：实现简单；适用于多处理机环境

缺点：不满足让权等待原则，可能会出现忙等

#### 同时共享方式

系统中的某些资源，允许一个时间段内由多个进程“同时”对他们进行访问



